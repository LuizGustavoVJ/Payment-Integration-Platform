<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GatewayIntegrationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Payment Integration Platform</a> &gt; <a href="index.source.html" class="el_package">com.pip.service</a> &gt; <span class="el_source">GatewayIntegrationService.java</span></div><h1>GatewayIntegrationService.java</h1><pre class="source lang-java linenums">package com.pip.service;

import com.pip.dto.AuthorizationRequest;
import com.pip.dto.CaptureRequest;
import com.pip.dto.VoidRequest;
import com.pip.dto.PaymentResponse;
import com.pip.model.Gateway;
import com.pip.model.Transacao;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.time.ZonedDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Serviço de integração com gateways de pagamento
 * 
 * Implementa padrões de resiliência:
 * - Circuit Breaker: Protege contra falhas em cascata
 * - Retry: Tenta novamente em caso de falhas temporárias
 * - Timeout: Limita tempo de espera
 * - Fallback: Roteamento alternativo em caso de falha
 * 
 * @author Luiz Gustavo Finotello
 */
@Service
<span class="nc" id="L34">public class GatewayIntegrationService {</span>

<span class="nc" id="L36">    private static final Logger logger = LoggerFactory.getLogger(GatewayIntegrationService.class);</span>

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private GatewayRoutingService routingService;

    /**
     * Processa autorização de pagamento com resiliência
     * 
     * @param gateway Gateway para processar
     * @param request Dados da autorização
     * @param transacao Transação sendo processada
     * @return Resposta do gateway
     */
    @CircuitBreaker(name = &quot;gatewayService&quot;, fallbackMethod = &quot;authorizeFallback&quot;)
    @Retry(name = &quot;gatewayService&quot;)
    public PaymentResponse authorize(Gateway gateway, AuthorizationRequest request, Transacao transacao) {
<span class="nc" id="L55">        logger.info(&quot;Processando autorização no gateway {} para transação {}&quot;, </span>
<span class="nc" id="L56">            gateway.getCodigo(), transacao.getTransactionId());</span>

<span class="nc" id="L58">        long startTime = System.currentTimeMillis();</span>

        try {
            // Preparar requisição
<span class="nc" id="L62">            String url = gateway.getUrlAtiva() + &quot;/authorize&quot;;</span>
<span class="nc" id="L63">            HttpHeaders headers = prepararHeaders(gateway);</span>
<span class="nc" id="L64">            Map&lt;String, Object&gt; payload = prepararPayloadAutorizacao(request, transacao);</span>

<span class="nc" id="L66">            HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(payload, headers);</span>

            // Fazer chamada ao gateway
<span class="nc" id="L69">            ResponseEntity&lt;Map&gt; response = restTemplate.exchange(</span>
                url,
                HttpMethod.POST,
                entity,
                Map.class
            );

<span class="nc" id="L76">            long responseTime = System.currentTimeMillis() - startTime;</span>

            // Processar resposta
<span class="nc" id="L79">            PaymentResponse paymentResponse = processarResposta(response, responseTime);</span>

            // Atualizar métricas do gateway
<span class="nc" id="L82">            atualizarMetricasGateway(gateway, true, responseTime);</span>

<span class="nc" id="L84">            logger.info(&quot;Autorização processada com sucesso. Gateway: {}, Tempo: {}ms&quot;, </span>
<span class="nc" id="L85">                gateway.getCodigo(), responseTime);</span>

<span class="nc" id="L87">            return paymentResponse;</span>

<span class="nc" id="L89">        } catch (Exception e) {</span>
<span class="nc" id="L90">            long responseTime = System.currentTimeMillis() - startTime;</span>
            
<span class="nc" id="L92">            logger.error(&quot;Erro ao processar autorização no gateway {}: {}&quot;, </span>
<span class="nc" id="L93">                gateway.getCodigo(), e.getMessage());</span>

            // Atualizar métricas do gateway (falha)
<span class="nc" id="L96">            atualizarMetricasGateway(gateway, false, responseTime);</span>

<span class="nc" id="L98">            throw new RuntimeException(&quot;Falha na comunicação com gateway: &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * Fallback para autorização em caso de falha
     */
    private PaymentResponse authorizeFallback(Gateway gateway, AuthorizationRequest request, 
                                              Transacao transacao, Exception e) {
<span class="nc" id="L107">        logger.warn(&quot;Executando fallback para autorização. Gateway falho: {}, Erro: {}&quot;, </span>
<span class="nc" id="L108">            gateway.getCodigo(), e.getMessage());</span>

        // Tentar gateway alternativo
<span class="nc" id="L111">        Gateway gatewayFallback = routingService.selecionarGatewayFallback(</span>
<span class="nc" id="L112">            transacao.getLojista(), </span>
            gateway, 
<span class="nc" id="L114">            transacao.getValor()</span>
        );

<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (gatewayFallback != null) {</span>
<span class="nc" id="L118">            logger.info(&quot;Tentando gateway alternativo: {}&quot;, gatewayFallback.getCodigo());</span>
<span class="nc" id="L119">            return authorize(gatewayFallback, request, transacao);</span>
        }

        // Se não houver alternativa, retornar erro
<span class="nc" id="L123">        PaymentResponse errorResponse = new PaymentResponse();</span>
<span class="nc" id="L124">        errorResponse.setSuccess(false);</span>
<span class="nc" id="L125">        errorResponse.setStatus(&quot;FAILED&quot;);</span>
<span class="nc" id="L126">        errorResponse.setErrorCode(&quot;GATEWAY_UNAVAILABLE&quot;);</span>
<span class="nc" id="L127">        errorResponse.setErrorMessage(&quot;Todos os gateways estão indisponíveis no momento&quot;);</span>
<span class="nc" id="L128">        errorResponse.setTimestamp(ZonedDateTime.now());</span>

<span class="nc" id="L130">        return errorResponse;</span>
    }

    /**
     * Processa captura de pagamento com resiliência
     */
    @CircuitBreaker(name = &quot;gatewayService&quot;, fallbackMethod = &quot;captureFallback&quot;)
    @Retry(name = &quot;gatewayService&quot;)
    public PaymentResponse capture(Gateway gateway, CaptureRequest request, Transacao transacao) {
<span class="nc" id="L139">        logger.info(&quot;Processando captura no gateway {} para transação {}&quot;, </span>
<span class="nc" id="L140">            gateway.getCodigo(), transacao.getTransactionId());</span>

<span class="nc" id="L142">        long startTime = System.currentTimeMillis();</span>

        try {
<span class="nc" id="L145">            String url = gateway.getUrlAtiva() + &quot;/capture&quot;;</span>
<span class="nc" id="L146">            HttpHeaders headers = prepararHeaders(gateway);</span>
<span class="nc" id="L147">            Map&lt;String, Object&gt; payload = prepararPayloadCaptura(request, transacao);</span>

<span class="nc" id="L149">            HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(payload, headers);</span>

<span class="nc" id="L151">            ResponseEntity&lt;Map&gt; response = restTemplate.exchange(</span>
                url,
                HttpMethod.POST,
                entity,
                Map.class
            );

<span class="nc" id="L158">            long responseTime = System.currentTimeMillis() - startTime;</span>

<span class="nc" id="L160">            PaymentResponse paymentResponse = processarResposta(response, responseTime);</span>
<span class="nc" id="L161">            atualizarMetricasGateway(gateway, true, responseTime);</span>

<span class="nc" id="L163">            logger.info(&quot;Captura processada com sucesso. Gateway: {}, Tempo: {}ms&quot;, </span>
<span class="nc" id="L164">                gateway.getCodigo(), responseTime);</span>

<span class="nc" id="L166">            return paymentResponse;</span>

<span class="nc" id="L168">        } catch (Exception e) {</span>
<span class="nc" id="L169">            long responseTime = System.currentTimeMillis() - startTime;</span>
            
<span class="nc" id="L171">            logger.error(&quot;Erro ao processar captura no gateway {}: {}&quot;, </span>
<span class="nc" id="L172">                gateway.getCodigo(), e.getMessage());</span>

<span class="nc" id="L174">            atualizarMetricasGateway(gateway, false, responseTime);</span>

<span class="nc" id="L176">            throw new RuntimeException(&quot;Falha na comunicação com gateway: &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * Fallback para captura
     */
    private PaymentResponse captureFallback(Gateway gateway, CaptureRequest request, 
                                           Transacao transacao, Exception e) {
<span class="nc" id="L185">        logger.error(&quot;Falha na captura sem possibilidade de fallback. Gateway: {}, Erro: {}&quot;, </span>
<span class="nc" id="L186">            gateway.getCodigo(), e.getMessage());</span>

<span class="nc" id="L188">        PaymentResponse errorResponse = new PaymentResponse();</span>
<span class="nc" id="L189">        errorResponse.setSuccess(false);</span>
<span class="nc" id="L190">        errorResponse.setStatus(&quot;FAILED&quot;);</span>
<span class="nc" id="L191">        errorResponse.setErrorCode(&quot;CAPTURE_FAILED&quot;);</span>
<span class="nc" id="L192">        errorResponse.setErrorMessage(&quot;Falha ao capturar pagamento: &quot; + e.getMessage());</span>
<span class="nc" id="L193">        errorResponse.setTimestamp(ZonedDateTime.now());</span>

<span class="nc" id="L195">        return errorResponse;</span>
    }

    /**
     * Processa cancelamento de pagamento com resiliência
     */
    @CircuitBreaker(name = &quot;gatewayService&quot;, fallbackMethod = &quot;voidFallback&quot;)
    @Retry(name = &quot;gatewayService&quot;)
    public PaymentResponse voidTransaction(Gateway gateway, VoidRequest request, Transacao transacao) {
<span class="nc" id="L204">        logger.info(&quot;Processando cancelamento no gateway {} para transação {}&quot;, </span>
<span class="nc" id="L205">            gateway.getCodigo(), transacao.getTransactionId());</span>

<span class="nc" id="L207">        long startTime = System.currentTimeMillis();</span>

        try {
<span class="nc" id="L210">            String url = gateway.getUrlAtiva() + &quot;/void&quot;;</span>
<span class="nc" id="L211">            HttpHeaders headers = prepararHeaders(gateway);</span>
<span class="nc" id="L212">            Map&lt;String, Object&gt; payload = prepararPayloadVoid(request, transacao);</span>

<span class="nc" id="L214">            HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(payload, headers);</span>

<span class="nc" id="L216">            ResponseEntity&lt;Map&gt; response = restTemplate.exchange(</span>
                url,
                HttpMethod.POST,
                entity,
                Map.class
            );

<span class="nc" id="L223">            long responseTime = System.currentTimeMillis() - startTime;</span>

<span class="nc" id="L225">            PaymentResponse paymentResponse = processarResposta(response, responseTime);</span>
<span class="nc" id="L226">            atualizarMetricasGateway(gateway, true, responseTime);</span>

<span class="nc" id="L228">            logger.info(&quot;Cancelamento processado com sucesso. Gateway: {}, Tempo: {}ms&quot;, </span>
<span class="nc" id="L229">                gateway.getCodigo(), responseTime);</span>

<span class="nc" id="L231">            return paymentResponse;</span>

<span class="nc" id="L233">        } catch (Exception e) {</span>
<span class="nc" id="L234">            long responseTime = System.currentTimeMillis() - startTime;</span>
            
<span class="nc" id="L236">            logger.error(&quot;Erro ao processar cancelamento no gateway {}: {}&quot;, </span>
<span class="nc" id="L237">                gateway.getCodigo(), e.getMessage());</span>

<span class="nc" id="L239">            atualizarMetricasGateway(gateway, false, responseTime);</span>

<span class="nc" id="L241">            throw new RuntimeException(&quot;Falha na comunicação com gateway: &quot; + e.getMessage(), e);</span>
        }
    }

    /**
     * Fallback para cancelamento
     */
    private PaymentResponse voidFallback(Gateway gateway, VoidRequest request, 
                                        Transacao transacao, Exception e) {
<span class="nc" id="L250">        logger.error(&quot;Falha no cancelamento sem possibilidade de fallback. Gateway: {}, Erro: {}&quot;, </span>
<span class="nc" id="L251">            gateway.getCodigo(), e.getMessage());</span>

<span class="nc" id="L253">        PaymentResponse errorResponse = new PaymentResponse();</span>
<span class="nc" id="L254">        errorResponse.setSuccess(false);</span>
<span class="nc" id="L255">        errorResponse.setStatus(&quot;FAILED&quot;);</span>
<span class="nc" id="L256">        errorResponse.setErrorCode(&quot;VOID_FAILED&quot;);</span>
<span class="nc" id="L257">        errorResponse.setErrorMessage(&quot;Falha ao cancelar pagamento: &quot; + e.getMessage());</span>
<span class="nc" id="L258">        errorResponse.setTimestamp(ZonedDateTime.now());</span>

<span class="nc" id="L260">        return errorResponse;</span>
    }

    /**
     * Prepara headers HTTP para requisição ao gateway
     */
    private HttpHeaders prepararHeaders(Gateway gateway) {
<span class="nc" id="L267">        HttpHeaders headers = new HttpHeaders();</span>
<span class="nc" id="L268">        headers.setContentType(MediaType.APPLICATION_JSON);</span>
        
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (gateway.getApiKey() != null) {</span>
<span class="nc" id="L271">            headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + gateway.getApiKey());</span>
        }
        
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (gateway.getMerchantId() != null) {</span>
<span class="nc" id="L275">            headers.set(&quot;Merchant-Id&quot;, gateway.getMerchantId());</span>
        }

<span class="nc" id="L278">        return headers;</span>
    }

    /**
     * Prepara payload para autorização
     */
    private Map&lt;String, Object&gt; prepararPayloadAutorizacao(AuthorizationRequest request, Transacao transacao) {
<span class="nc" id="L285">        Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();</span>
<span class="nc" id="L286">        payload.put(&quot;transaction_id&quot;, transacao.getTransactionId());</span>
<span class="nc" id="L287">        payload.put(&quot;amount&quot;, request.getAmount());</span>
<span class="nc" id="L288">        payload.put(&quot;currency&quot;, request.getCurrency());</span>
<span class="nc" id="L289">        payload.put(&quot;card_token&quot;, request.getCardToken());</span>
<span class="nc" id="L290">        payload.put(&quot;installments&quot;, request.getInstallments());</span>
<span class="nc" id="L291">        payload.put(&quot;description&quot;, request.getDescription());</span>
        
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (request.getCustomer() != null) {</span>
<span class="nc" id="L294">            payload.put(&quot;customer&quot;, request.getCustomer());</span>
        }

<span class="nc" id="L297">        return payload;</span>
    }

    /**
     * Prepara payload para captura
     */
    private Map&lt;String, Object&gt; prepararPayloadCaptura(CaptureRequest request, Transacao transacao) {
<span class="nc" id="L304">        Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();</span>
<span class="nc" id="L305">        payload.put(&quot;transaction_id&quot;, transacao.getTransactionId());</span>
<span class="nc" id="L306">        payload.put(&quot;gateway_transaction_id&quot;, transacao.getGatewayTransactionId());</span>
<span class="nc" id="L307">        payload.put(&quot;amount&quot;, request.getAmount());</span>

<span class="nc" id="L309">        return payload;</span>
    }

    /**
     * Prepara payload para cancelamento
     */
    private Map&lt;String, Object&gt; prepararPayloadVoid(VoidRequest request, Transacao transacao) {
<span class="nc" id="L316">        Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();</span>
<span class="nc" id="L317">        payload.put(&quot;transaction_id&quot;, transacao.getTransactionId());</span>
<span class="nc" id="L318">        payload.put(&quot;gateway_transaction_id&quot;, transacao.getGatewayTransactionId());</span>
<span class="nc" id="L319">        payload.put(&quot;reason&quot;, request.getReason());</span>

<span class="nc" id="L321">        return payload;</span>
    }

    /**
     * Processa resposta do gateway
     */
    private PaymentResponse processarResposta(ResponseEntity&lt;Map&gt; response, long responseTime) {
<span class="nc" id="L328">        Map&lt;String, Object&gt; body = response.getBody();</span>

<span class="nc" id="L330">        PaymentResponse paymentResponse = new PaymentResponse();</span>
<span class="nc" id="L331">        paymentResponse.setSuccess(response.getStatusCode().is2xxSuccessful());</span>
<span class="nc" id="L332">        paymentResponse.setStatus((String) body.get(&quot;status&quot;));</span>
<span class="nc" id="L333">        paymentResponse.setTransactionId((String) body.get(&quot;transaction_id&quot;));</span>
<span class="nc" id="L334">        paymentResponse.setGatewayTransactionId((String) body.get(&quot;gateway_transaction_id&quot;));</span>
<span class="nc" id="L335">        paymentResponse.setAuthorizationCode((String) body.get(&quot;authorization_code&quot;));</span>
<span class="nc" id="L336">        paymentResponse.setNsu((String) body.get(&quot;nsu&quot;));</span>
<span class="nc" id="L337">        paymentResponse.setTid((String) body.get(&quot;tid&quot;));</span>
<span class="nc" id="L338">        paymentResponse.setResponseTime(responseTime);</span>
<span class="nc" id="L339">        paymentResponse.setTimestamp(ZonedDateTime.now());</span>

<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (body.containsKey(&quot;error_code&quot;)) {</span>
<span class="nc" id="L342">            paymentResponse.setErrorCode((String) body.get(&quot;error_code&quot;));</span>
<span class="nc" id="L343">            paymentResponse.setErrorMessage((String) body.get(&quot;error_message&quot;));</span>
        }

<span class="nc" id="L346">        return paymentResponse;</span>
    }

    /**
     * Atualiza métricas do gateway após processamento
     */
    private void atualizarMetricasGateway(Gateway gateway, boolean sucesso, long tempoResposta) {
<span class="nc" id="L353">        gateway.registrarTransacao(sucesso, 0L, tempoResposta);</span>
        // O save será feito pelo serviço que chamou este método
<span class="nc" id="L355">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>